<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arbitrage Scanner</title>
    <style>
      :root {
        --bg-top: #041b24;
        --bg-bottom: #02070d;
        --card: rgba(8, 29, 39, 0.84);
        --line: rgba(90, 174, 196, 0.26);
        --text: #eaf7fb;
        --muted: #89aab5;
        --ok: #2ecc71;
        --warn: #f1c40f;
        --danger: #e74c3c;
        --accent: #3cc4dd;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        color: var(--text);
        background:
          radial-gradient(circle at 20% 10%, rgba(60, 196, 221, 0.2), transparent 40%),
          radial-gradient(circle at 90% 0%, rgba(255, 110, 74, 0.15), transparent 28%),
          linear-gradient(165deg, var(--bg-top), var(--bg-bottom));
      }

      .shell {
        width: min(1260px, 95vw);
        margin: 24px auto 28px;
        padding: 18px;
        border: 1px solid var(--line);
        border-radius: 18px;
        background: var(--card);
        backdrop-filter: blur(6px);
      }

      h1 {
        margin: 0;
        font-size: clamp(22px, 2.5vw, 34px);
      }

      .meta {
        margin-top: 8px;
        color: var(--muted);
        font-family: "IBM Plex Mono", Consolas, monospace;
        font-size: 12px;
      }

      .pulse {
        display: inline-block;
        width: 9px;
        height: 9px;
        border-radius: 50%;
        margin-right: 8px;
        background: var(--accent);
        box-shadow: 0 0 0 rgba(60, 196, 221, 0.5);
        animation: ping 1.8s infinite;
      }

      @keyframes ping {
        0% { box-shadow: 0 0 0 0 rgba(60, 196, 221, 0.45); }
        70% { box-shadow: 0 0 0 9px rgba(60, 196, 221, 0); }
        100% { box-shadow: 0 0 0 0 rgba(60, 196, 221, 0); }
      }

      .grid {
        margin-top: 16px;
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 14px;
      }

      .card {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: rgba(5, 21, 29, 0.66);
      }

      .settings {
        padding: 12px;
      }

      .section-title {
        margin: 0 0 10px;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 0.02em;
        color: #bde9f2;
      }

      .row {
        margin-bottom: 10px;
      }

      label.small {
        display: block;
        color: var(--muted);
        font-size: 12px;
        margin-bottom: 4px;
      }

      input[type="number"], input[type="text"], select {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: rgba(5, 21, 29, 0.9);
        color: var(--text);
        padding: 8px 9px;
      }

      .chip-row {
        display: flex;
        gap: 8px;
      }

      button {
        border: 1px solid var(--line);
        background: rgba(16, 74, 92, 0.5);
        color: var(--text);
        border-radius: 8px;
        padding: 7px 10px;
        cursor: pointer;
      }

      button:hover {
        background: rgba(16, 74, 92, 0.75);
      }

      .save {
        width: 100%;
        font-weight: 700;
        margin-top: 6px;
      }

      .hint {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      .picker {
        max-height: 180px;
        overflow: auto;
        border: 1px solid rgba(90, 174, 196, 0.2);
        border-radius: 8px;
        padding: 8px;
        scrollbar-width: thin;
        scrollbar-color: rgba(84, 138, 152, 0.55) rgba(7, 28, 38, 0.6);
      }

      .picker::-webkit-scrollbar {
        width: 10px;
      }

      .picker::-webkit-scrollbar-track {
        background: rgba(7, 28, 38, 0.6);
        border-radius: 8px;
      }

      .picker::-webkit-scrollbar-thumb {
        background: linear-gradient(
          180deg,
          rgba(93, 157, 174, 0.55),
          rgba(56, 109, 122, 0.55)
        );
        border: 2px solid rgba(7, 28, 38, 0.7);
        border-radius: 8px;
      }

      .picker::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(
          180deg,
          rgba(100, 169, 188, 0.7),
          rgba(62, 125, 139, 0.7)
        );
      }

      .picker label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 3px 0;
        font-size: 13px;
      }

      .content {
        padding: 0;
        overflow: hidden;
      }

      .tabbar {
        display: flex;
        gap: 8px;
        padding: 12px;
        border-bottom: 1px solid rgba(90, 174, 196, 0.16);
      }

      .tabbtn {
        border: 1px solid var(--line);
        background: rgba(10, 44, 58, 0.7);
        color: var(--muted);
        border-radius: 999px;
        padding: 7px 12px;
        font-weight: 600;
      }

      .tabbtn.active {
        color: var(--text);
        background: rgba(16, 74, 92, 0.85);
      }

      .panel {
        display: none;
      }

      .panel.active {
        display: block;
      }

      .toolbar {
        display: grid;
        grid-template-columns: 1fr 180px;
        gap: 10px;
        padding: 12px;
        border-bottom: 1px solid rgba(90, 174, 196, 0.16);
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(4, minmax(100px, 1fr));
        gap: 10px;
        padding: 12px;
        border-bottom: 1px solid rgba(90, 174, 196, 0.16);
      }

      .stat {
        border: 1px solid rgba(90, 174, 196, 0.2);
        border-radius: 8px;
        padding: 9px;
      }

      .stat .k {
        color: var(--muted);
        font-size: 11px;
      }

      .stat .v {
        margin-top: 4px;
        font-size: 18px;
        font-weight: 700;
      }

      .status-wrap {
        padding: 12px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      th, td {
        text-align: left;
        padding: 10px 12px;
        border-bottom: 1px solid rgba(90, 174, 196, 0.12);
        font-size: 14px;
      }

      th {
        color: var(--muted);
        cursor: pointer;
        user-select: none;
      }

      th.sort {
        color: #d2f4fb;
      }

      tr:hover td {
        background: rgba(50, 112, 126, 0.15);
      }

      .risk-green { color: var(--ok); }
      .risk-yellow { color: var(--warn); }
      .risk-red { color: var(--danger); }
      .ok { color: var(--ok); }
      .bad { color: var(--danger); }

      .mono {
        font-family: "IBM Plex Mono", Consolas, monospace;
      }

      .view-levtsov .row-net {
        display: none;
      }

      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 760px) {
        .toolbar {
          grid-template-columns: 1fr;
        }
        .stats {
          grid-template-columns: 1fr 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <h1><span class="pulse"></span>Arbitrage Scanner</h1>
      <div class="meta" id="meta">Connecting...</div>

      <div class="grid">
        <div class="card settings">
          <p class="section-title">Settings</p>

          <div class="row">
            <label class="small" for="scanInterval">Scan interval</label>
            <select id="scanInterval"></select>
          </div>

          <div class="row">
            <label class="small" for="tradeNotional">Trade size (USDT)</label>
            <input id="tradeNotional" type="number" min="1" step="10" />
          </div>

          <div class="row">
            <label class="small" for="minSpreadDiff">Min Levtsov spread (%)</label>
            <input id="minSpreadDiff" type="number" min="0" step="0.01" />
          </div>

          <div class="row row-net">
            <label class="small" for="minNetEdge">Min net edge (%)</label>
            <input id="minNetEdge" type="number" step="0.1" />
          </div>

          <div class="row row-net">
            <label class="small" for="takerFeeBps">Taker fee (bps, one side)</label>
            <input id="takerFeeBps" type="number" min="0" step="0.1" />
          </div>

          <div class="row row-net">
            <label class="small" for="slippageBps">Slippage (bps)</label>
            <input id="slippageBps" type="number" min="0" step="0.1" />
          </div>

          <div class="row row-net">
            <label class="small" for="withdrawCostUsdt">Withdraw/rebalance cost (USDT)</label>
            <input id="withdrawCostUsdt" type="number" min="0" step="0.1" />
          </div>

          <div class="row">
            <label class="small">Exchanges</label>
            <div class="chip-row">
              <button id="exAll" type="button">All</button>
              <button id="exNone" type="button">None</button>
            </div>
            <div class="picker" id="exchanges"></div>
          </div>

          <div class="row">
            <label class="small">Symbols</label>
            <input id="symbolsSearch" type="text" placeholder="Find symbol..." />
            <div class="chip-row">
              <button id="symAll" type="button">All</button>
              <button id="symNone" type="button">None</button>
              <button id="symLowLiq" type="button">Low-liq preset</button>
            </div>
            <div class="picker" id="symbols"></div>
          </div>

          <button class="save" id="saveSettings" type="button">Save settings</button>
          <div class="hint" id="breakevenHint">Break-even gross edge: -</div>
        </div>

        <div class="card content">
          <div class="tabbar">
            <button class="tabbtn active" id="tabLevtsov" type="button">Levtsov Spread</button>
            <button class="tabbtn" id="tabNet" type="button">Net Edge</button>
            <button class="tabbtn" id="tabStatus" type="button">Status</button>
          </div>

          <div class="panel active" id="oppsPanel">
            <div class="toolbar">
              <div>
                <label class="small" for="symbolFilter">Filter by symbol</label>
                <input id="symbolFilter" type="text" placeholder="e.g. BTC, ETH-USDT, SOL" />
              </div>
              <div>
                <label class="small">Rows</label>
                <div class="mono" id="rowLabel">0</div>
              </div>
            </div>

            <div class="stats">
              <div class="stat"><div class="k" id="sTopLabel">Top Levtsov Spread</div><div class="v" id="sTop">0.000%</div></div>
              <div class="stat"><div class="k" id="sAvgLabel">Avg Levtsov Spread</div><div class="v" id="sAvg">0.000%</div></div>
              <div class="stat"><div class="k" id="sPnlLabel">Avg Gross Edge</div><div class="v" id="sPnl">0.000%</div></div>
              <div class="stat"><div class="k">Active Symbols</div><div class="v" id="sSym">0</div></div>
            </div>

            <table>
              <thead>
                <tr id="oppsHead"></tr>
              </thead>
              <tbody id="tbody"></tbody>
            </table>
          </div>

          <div class="panel" id="statusPanel">
            <div class="status-wrap">
              <div class="stats">
                <div class="stat"><div class="k">Connectors</div><div class="v" id="stConnectors">0</div></div>
                <div class="stat"><div class="k">Books</div><div class="v" id="stBooks">0</div></div>
                <div class="stat"><div class="k">Fresh Ratio</div><div class="v" id="stFreshRatio">0%</div></div>
                <div class="stat"><div class="k">Last Scan</div><div class="v" id="stLastScan">-</div></div>
              </div>
              <table>
                <thead>
                  <tr>
                    <th>Exchange</th>
                    <th>Connector</th>
                    <th>Mapped/Requested</th>
                    <th>Books</th>
                    <th>Fresh</th>
                    <th>Stale</th>
                    <th>Newest Age (ms)</th>
                  </tr>
                </thead>
                <tbody id="statusTbody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const VIEW_COLUMNS = {
        levtsov: [
          { key: "symbol", label: "Symbol" },
          { key: "buy_exchange", label: "Buy" },
          { key: "sell_exchange", label: "Sell" },
          { key: "buy_vwap", label: "Buy price" },
          { key: "sell_vwap", label: "Sell price" },
          { key: "levtsov_spread_pct", label: "Levtsov Spread" },
          { key: "gross_edge_pct", label: "Gross Edge" },
          { key: "available_qty", label: "Qty" }
        ],
        net: [
          { key: "symbol", label: "Symbol" },
          { key: "buy_exchange", label: "Buy" },
          { key: "sell_exchange", label: "Sell" },
          { key: "buy_vwap", label: "Buy price" },
          { key: "sell_vwap", label: "Sell price" },
          { key: "net_edge_pct", label: "Net Edge" },
          { key: "gross_edge_pct", label: "Gross Edge" },
          { key: "available_qty", label: "Qty" },
          { key: "expected_profit_usdt", label: "Profit USDT" },
          { key: "risk_flag", label: "Risk" }
        ]
      };

      const state = {
        rows: [],
        activeView: "levtsov",
        sort: { key: "levtsov_spread_pct", dir: "desc" },
        symbolFilter: "",
        symbolSettingsFilter: "",
        settings: null,
        selectedSymbols: new Set()
      };

      const LOW_LIQ_SYMBOLS = [
        "ARB-USDT", "OP-USDT", "SUI-USDT", "SEI-USDT", "APT-USDT",
        "TON-USDT", "NEAR-USDT", "TAO-USDT", "HYPE-USDT", "ENA-USDT",
        "ONDO-USDT", "RNDR-USDT", "RENDER-USDT", "INJ-USDT", "AR-USDT",
        "JUP-USDT", "RUNE-USDT", "DYDX-USDT", "TIA-USDT", "LDO-USDT"
      ];

      const shell = document.querySelector(".shell");
      const meta = document.getElementById("meta");
      const tbody = document.getElementById("tbody");
      const oppsHead = document.getElementById("oppsHead");
      const symbolFilterInput = document.getElementById("symbolFilter");
      const rowLabel = document.getElementById("rowLabel");

      const scanIntervalEl = document.getElementById("scanInterval");
      const tradeNotionalEl = document.getElementById("tradeNotional");
      const minSpreadDiffEl = document.getElementById("minSpreadDiff");
      const minNetEdgeEl = document.getElementById("minNetEdge");
      const takerFeeBpsEl = document.getElementById("takerFeeBps");
      const slippageBpsEl = document.getElementById("slippageBps");
      const withdrawCostUsdtEl = document.getElementById("withdrawCostUsdt");
      const breakevenHintEl = document.getElementById("breakevenHint");
      const exchangesEl = document.getElementById("exchanges");
      const symbolsEl = document.getElementById("symbols");
      const symbolsSearchEl = document.getElementById("symbolsSearch");
      const statusTbody = document.getElementById("statusTbody");
      const tabLevtsov = document.getElementById("tabLevtsov");
      const tabNet = document.getElementById("tabNet");
      const tabStatus = document.getElementById("tabStatus");
      const oppsPanel = document.getElementById("oppsPanel");
      const statusPanel = document.getElementById("statusPanel");
      const sTopLabel = document.getElementById("sTopLabel");
      const sAvgLabel = document.getElementById("sAvgLabel");
      const sPnlLabel = document.getElementById("sPnlLabel");

      function setMeta(text) {
        meta.textContent = text;
      }

      function currentColumns() {
        return VIEW_COLUMNS[state.activeView];
      }

      function ensureSortForView() {
        const keys = new Set(currentColumns().map((col) => col.key));
        if (!keys.has(state.sort.key)) {
          state.sort.key = state.activeView === "levtsov" ? "levtsov_spread_pct" : "net_edge_pct";
          state.sort.dir = "desc";
        }
      }

      function switchTab(name) {
        const isStatus = name === "status";
        if (!isStatus) {
          state.activeView = name;
        }
        tabLevtsov.classList.toggle("active", !isStatus && state.activeView === "levtsov");
        tabNet.classList.toggle("active", !isStatus && state.activeView === "net");
        tabStatus.classList.toggle("active", isStatus);
        oppsPanel.classList.toggle("active", !isStatus);
        statusPanel.classList.toggle("active", isStatus);
        shell.classList.toggle("view-levtsov", state.activeView === "levtsov");
        updateBreakevenHint();
        if (!isStatus) {
          ensureSortForView();
          renderTableHeader();
          updateSortHeaderStyles();
          render();
        }
      }

      async function loadSettings() {
        const res = await fetch("/api/settings");
        const data = await res.json();
        state.settings = data;
        hydrateSettingsUI(data);
      }

      function hydrateSettingsUI(data) {
        scanIntervalEl.innerHTML = "";
        data.allowed_scan_intervals_sec.forEach((v) => {
          const opt = document.createElement("option");
          opt.value = String(v);
          opt.textContent = formatInterval(v);
          if (v === data.scan_interval_sec) opt.selected = true;
          scanIntervalEl.appendChild(opt);
        });
        tradeNotionalEl.value = String(data.trade_notional_usdt);
        minSpreadDiffEl.value = String(data.min_spread_diff_pct);
        minNetEdgeEl.value = String(data.min_net_edge_pct ?? 0);
        takerFeeBpsEl.value = String(data.taker_fee_bps ?? 10);
        slippageBpsEl.value = String(data.slippage_bps ?? 5);
        withdrawCostUsdtEl.value = String(data.withdraw_cost_usdt ?? 2);

        renderPicker(exchangesEl, data.available_exchanges, new Set(data.active_exchanges));
        state.selectedSymbols = new Set(data.active_symbols);
        renderSymbolsPicker();
        document.getElementById("sSym").textContent = String(data.active_symbols.length);
        updateBreakevenHint();
      }

      function renderPicker(root, values, selected) {
        root.innerHTML = "";
        values.forEach((value) => {
          const id = `${root.id}_${value}`;
          const label = document.createElement("label");
          label.setAttribute("for", id);
          const input = document.createElement("input");
          input.type = "checkbox";
          input.id = id;
          input.value = value;
          input.checked = selected.has(value);
          label.appendChild(input);
          label.appendChild(document.createTextNode(value));
          root.appendChild(label);
        });
      }

      function collectChecked(root) {
        return [...root.querySelectorAll("input[type='checkbox']:checked")].map((x) => x.value);
      }

      function renderSymbolsPicker() {
        symbolsEl.innerHTML = "";
        if (!state.settings) return;
        const needle = state.symbolSettingsFilter.trim().toLowerCase();
        const values = state.settings.available_symbols.filter((item) =>
          !needle || item.toLowerCase().includes(needle)
        );
        values.forEach((value) => {
          const id = `symbols_${value}`;
          const label = document.createElement("label");
          label.setAttribute("for", id);
          const input = document.createElement("input");
          input.type = "checkbox";
          input.id = id;
          input.value = value;
          input.checked = state.selectedSymbols.has(value);
          label.appendChild(input);
          label.appendChild(document.createTextNode(value));
          symbolsEl.appendChild(label);
        });
      }

      function syncSelectedSymbolsFromDom() {
        const visibleValues = [...symbolsEl.querySelectorAll("input[type='checkbox']")]
          .map((item) => item.value);
        visibleValues.forEach((value) => state.selectedSymbols.delete(value));
        symbolsEl.querySelectorAll("input[type='checkbox']:checked").forEach((item) => {
          state.selectedSymbols.add(item.value);
        });
      }

      async function saveSettings() {
        syncSelectedSymbolsFromDom();
        const payload = {
          scan_interval_sec: Number(scanIntervalEl.value),
          trade_notional_usdt: Number(tradeNotionalEl.value),
          min_spread_diff_pct: Number(minSpreadDiffEl.value),
          min_net_edge_pct: Number(minNetEdgeEl.value),
          taker_fee_bps: Number(takerFeeBpsEl.value),
          slippage_bps: Number(slippageBpsEl.value),
          withdraw_cost_usdt: Number(withdrawCostUsdtEl.value),
          active_exchanges: collectChecked(exchangesEl),
          active_symbols: Array.from(state.selectedSymbols)
        };
        const res = await fetch("/api/settings", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        state.settings = data;
        hydrateSettingsUI(data);
        await loadStatus();
        render();
        setMeta(`Settings saved at ${new Date().toLocaleTimeString()}`);
      }

      function updateBreakevenHint() {
        if (state.activeView === "levtsov") {
          breakevenHintEl.textContent =
            "Levtsov tab uses only Min Levtsov spread filter. Net costs are used in Net Edge tab.";
          return;
        }

        const tradeNotional = Number(tradeNotionalEl.value || 0);
        const minNet = Number(minNetEdgeEl.value || 0);
        const takerPct = (2 * Number(takerFeeBpsEl.value || 0)) / 100;
        const slippagePct = Number(slippageBpsEl.value || 0) / 100;
        const withdrawPct = tradeNotional > 0
          ? (Number(withdrawCostUsdtEl.value || 0) / tradeNotional) * 100
          : 0;
        const requiredGross = takerPct + slippagePct + withdrawPct + minNet;
        breakevenHintEl.textContent =
          `Break-even gross edge ~= ${requiredGross.toFixed(3)}% ` +
          `(fees ${takerPct.toFixed(3)}% + slippage ${slippagePct.toFixed(3)}% + withdraw ${withdrawPct.toFixed(3)}% + target net ${minNet.toFixed(3)}%)`;
      }

      async function loadStatus() {
        try {
          const res = await fetch("/api/status");
          const data = await res.json();
          renderStatus(data);
        } catch (err) {
          setMeta("Status fetch error");
        }
      }

      function renderStatus(data) {
        const counters = data.counters || {};
        const booksTotal = Number(counters.books_total || 0);
        const booksFresh = Number(counters.books_fresh || 0);
        const freshRatio = booksTotal > 0 ? (booksFresh / booksTotal) * 100 : 0;

        document.getElementById("stConnectors").textContent = String(counters.connectors_total || 0);
        document.getElementById("stBooks").textContent = String(booksTotal);
        document.getElementById("stFreshRatio").textContent = `${freshRatio.toFixed(1)}%`;
        document.getElementById("stLastScan").textContent = counters.last_scan_elapsed_ms != null
          ? `${Number(counters.last_scan_elapsed_ms).toFixed(1)} ms`
          : "-";

        statusTbody.innerHTML = "";
        (data.exchanges || []).forEach((row) => {
          const fresh = Number(row.books_fresh || 0);
          const total = Number(row.books_total || 0);
          const mapped = Number(row.mapped_symbols ?? 0);
          const requested = Number(row.requested_symbols ?? 0);
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${row.exchange || ""}</td>
            <td>${row.connector || ""}</td>
            <td>${mapped}/${requested}</td>
            <td>${total}</td>
            <td class="${fresh > 0 ? "ok" : ""}">${fresh}</td>
            <td class="${Number(row.books_stale || 0) > 0 ? "bad" : ""}">${row.books_stale || 0}</td>
            <td>${row.newest_age_ms ?? "-"}</td>
          `;
          statusTbody.appendChild(tr);
        });
      }

      function formatInterval(sec) {
        if (sec < 60) return `${sec} sec`;
        if (sec % 60 === 0) return `${sec / 60} min`;
        return `${sec}s`;
      }

      function parseSortValue(row, key) {
        const v = row[key];
        if (["buy_vwap", "sell_vwap", "levtsov_spread_pct", "net_edge_pct", "gross_edge_pct", "available_qty", "expected_profit_usdt"].includes(key)) {
          return Number(v || 0);
        }
        return String(v || "").toLowerCase();
      }

      function formatPrice(value) {
        const n = Number(value || 0);
        if (n >= 1000) return n.toFixed(2);
        if (n >= 1) return n.toFixed(4);
        return n.toFixed(6);
      }

      function formatCell(row, key) {
        if (key === "buy_vwap" || key === "sell_vwap") return formatPrice(row[key]);
        if (key === "levtsov_spread_pct" || key === "net_edge_pct" || key === "gross_edge_pct") {
          return `${Number(row[key] || 0).toFixed(3)}%`;
        }
        if (key === "available_qty") return Number(row[key] || 0).toFixed(5);
        if (key === "expected_profit_usdt") return Number(row[key] || 0).toFixed(3);
        return String(row[key] ?? "");
      }

      function applyFilterSort(rows) {
        let out = rows.slice();
        if (state.symbolFilter) {
          const needle = state.symbolFilter.toLowerCase();
          out = out.filter((r) => String(r.symbol || "").toLowerCase().includes(needle));
        }

        if (state.activeView === "levtsov") {
          const minLevtsov = Number(minSpreadDiffEl.value || 0);
          out = out.filter((r) => Number(r.levtsov_spread_pct || 0) >= minLevtsov);
        } else if (state.activeView === "net") {
          const minNet = Number(minNetEdgeEl.value || -999);
          out = out.filter((r) => Number(r.net_edge_pct || 0) >= minNet);
        }

        out.sort((a, b) => {
          const av = parseSortValue(a, state.sort.key);
          const bv = parseSortValue(b, state.sort.key);
          if (av < bv) return state.sort.dir === "asc" ? -1 : 1;
          if (av > bv) return state.sort.dir === "asc" ? 1 : -1;
          return 0;
        });
        return out;
      }

      function updateStats(rows) {
        if (state.activeView === "levtsov") {
          const top = rows[0]?.levtsov_spread_pct || 0;
          const avg = rows.length
            ? rows.reduce((s, r) => s + Number(r.levtsov_spread_pct || 0), 0) / rows.length
            : 0;
          const avgGross = rows.length
            ? rows.reduce((s, r) => s + Number(r.gross_edge_pct || 0), 0) / rows.length
            : 0;
          sTopLabel.textContent = "Top Levtsov Spread";
          sAvgLabel.textContent = "Avg Levtsov Spread";
          sPnlLabel.textContent = "Avg Gross Edge";
          document.getElementById("sTop").textContent = `${Number(top).toFixed(3)}%`;
          document.getElementById("sAvg").textContent = `${Number(avg).toFixed(3)}%`;
          document.getElementById("sPnl").textContent = `${Number(avgGross).toFixed(3)}%`;
          return;
        }

        const top = rows[0]?.net_edge_pct || 0;
        const avg = rows.length ? rows.reduce((s, r) => s + Number(r.net_edge_pct || 0), 0) / rows.length : 0;
        const pnl = rows.slice(0, 10).reduce((s, r) => s + Number(r.expected_profit_usdt || 0), 0);
        sTopLabel.textContent = "Top Net Edge";
        sAvgLabel.textContent = "Avg Net Edge";
        sPnlLabel.textContent = "Projected PnL (Top 10)";
        document.getElementById("sTop").textContent = `${Number(top).toFixed(3)}%`;
        document.getElementById("sAvg").textContent = `${Number(avg).toFixed(3)}%`;
        document.getElementById("sPnl").textContent = Number(pnl).toFixed(2);
      }

      function renderTableHeader() {
        const cols = currentColumns();
        oppsHead.innerHTML = cols.map((col) => (
          `<th data-key="${col.key}" data-label="${col.label}">${col.label}</th>`
        )).join("");
      }

      function render() {
        const rows = applyFilterSort(state.rows);
        const cols = currentColumns();
        tbody.innerHTML = "";
        rows.slice(0, 150).forEach((row) => {
          const tr = document.createElement("tr");
          tr.innerHTML = cols.map((col) => {
            const cellValue = formatCell(row, col.key);
            if (col.key === "risk_flag") {
              return `<td class="risk-${String(row.risk_flag || "red")}">${cellValue}</td>`;
            }
            return `<td>${cellValue}</td>`;
          }).join("");
          tbody.appendChild(tr);
        });
        rowLabel.textContent = String(rows.length);
        updateSortHeaderStyles();
        updateStats(rows);
      }

      function updateSortHeaderStyles() {
        oppsHead.querySelectorAll("th[data-key]").forEach((th) => {
          const label = th.dataset.label || th.dataset.key;
          if (th.dataset.key === state.sort.key) {
            th.classList.add("sort");
            th.textContent = `${label} ${state.sort.dir === "asc" ? "^" : "v"}`;
          } else {
            th.classList.remove("sort");
            th.textContent = label;
          }
        });
      }

      function wireInteractions() {
        symbolFilterInput.addEventListener("input", () => {
          state.symbolFilter = symbolFilterInput.value.trim();
          render();
        });
        minSpreadDiffEl.addEventListener("input", render);
        minNetEdgeEl.addEventListener("input", () => {
          updateBreakevenHint();
          render();
        });
        tradeNotionalEl.addEventListener("input", updateBreakevenHint);
        takerFeeBpsEl.addEventListener("input", updateBreakevenHint);
        slippageBpsEl.addEventListener("input", updateBreakevenHint);
        withdrawCostUsdtEl.addEventListener("input", updateBreakevenHint);

        symbolsSearchEl.addEventListener("input", () => {
          syncSelectedSymbolsFromDom();
          state.symbolSettingsFilter = symbolsSearchEl.value;
          renderSymbolsPicker();
        });
        symbolsEl.addEventListener("change", () => {
          syncSelectedSymbolsFromDom();
          document.getElementById("sSym").textContent = String(state.selectedSymbols.size);
        });

        oppsHead.addEventListener("click", (event) => {
          const th = event.target.closest("th[data-key]");
          if (!th) return;
          const key = th.dataset.key;
          if (state.sort.key === key) {
            state.sort.dir = state.sort.dir === "asc" ? "desc" : "asc";
          } else {
            state.sort.key = key;
            state.sort.dir = "desc";
          }
          render();
        });

        document.getElementById("saveSettings").addEventListener("click", saveSettings);
        tabLevtsov.addEventListener("click", () => switchTab("levtsov"));
        tabNet.addEventListener("click", () => switchTab("net"));
        tabStatus.addEventListener("click", () => switchTab("status"));
        document.getElementById("exAll").addEventListener("click", () => {
          exchangesEl.querySelectorAll("input[type='checkbox']").forEach((x) => x.checked = true);
        });
        document.getElementById("exNone").addEventListener("click", () => {
          exchangesEl.querySelectorAll("input[type='checkbox']").forEach((x) => x.checked = false);
        });
        document.getElementById("symAll").addEventListener("click", () => {
          if (!state.settings) return;
          state.selectedSymbols = new Set(state.settings.available_symbols);
          renderSymbolsPicker();
          document.getElementById("sSym").textContent = String(state.selectedSymbols.size);
        });
        document.getElementById("symNone").addEventListener("click", () => {
          state.selectedSymbols = new Set();
          renderSymbolsPicker();
          document.getElementById("sSym").textContent = "0";
        });
        document.getElementById("symLowLiq").addEventListener("click", () => {
          if (!state.settings) return;
          const available = new Set(state.settings.available_symbols || []);
          state.selectedSymbols = new Set(
            LOW_LIQ_SYMBOLS.filter((symbol) => available.has(symbol))
          );
          renderSymbolsPicker();
          document.getElementById("sSym").textContent = String(state.selectedSymbols.size);
        });
      }

      function connectWs() {
        const schema = window.location.protocol === "https:" ? "wss" : "ws";
        const ws = new WebSocket(`${schema}://${window.location.host}/ws/opportunities`);
        ws.onopen = () => setMeta("Live stream connected");
        ws.onclose = () => setMeta("Stream disconnected");
        ws.onerror = () => setMeta("Stream error");
        ws.onmessage = (event) => {
          const payload = JSON.parse(event.data);
          state.rows = payload.opportunities || [];
          render();
          setMeta(`Updated ${new Date().toLocaleTimeString()} | rows: ${payload.count || 0}`);
        };
      }

      async function boot() {
        wireInteractions();
        await loadSettings();
        await loadStatus();
        setInterval(loadStatus, 5000);
        switchTab("levtsov");
        connectWs();
      }

      boot();
    </script>
  </body>
</html>
